(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{"+QBq":function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return s})),n.d(t,"default",(function(){return u}));n("rzGZ"),n("Dq+y"),n("8npG"),n("Ggvi"),n("E5k/"),n("q1tI");var r=n("7ljp"),a=n("Bl7J");var s={},o={_frontmatter:s},i=a.a;function u(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,["components"]);return Object(r.b)(i,Object.assign({},o,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",null,n.pageContext.frontmatter.title),Object(r.b)("p",null,"Custom fields allow you to extend your types with custom logic as well as make joins between your local data and remote data."),Object(r.b)("p",null,"Let's say we are building an app for managing projects.  Users will login with their GitHub id and we want to connect some data about their work stored in Dgraph with say their GitHub profile, issues, etc."),Object(r.b)("p",null,"Our first version of our users might start out with just their GitHub username and some data about what projects they are working on."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),"type User {\n    username: String! @id \n    projects: [Project]\n    tickets: [Ticket]\n}\n")),Object(r.b)("p",null,"We can then add their GitHub repositories by just extending the definitions with the types and custom field needed to make the remote call."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'# GitHub\'s repository type\ntype Respository @remote { ... }\n\n# Dgraph user type\ntype User {\n    # local user name = GitHub id\n    username: String! @id \n\n    # join local data with remote\n    repositories: [Repository] @custom(http: {\n        url:  "https://api.github.com/users/$username/repos",\n        method: GET\n    })\n}\n')),Object(r.b)("p",null,"We could similarly join with say the GitHub user details, or open pull requests, to further fill out the join between GitHub and our local data.  Instead of the REST API, let's use the GitHub GraphQL endpoint"),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'# GitHub\'s User type\ntype GitHubUser @remote { ... }\n\n# Dgraph user type\ntype User {\n    # local user name = GitHub id\n    username: String! @id \n\n    # join local data with remote\n    gitDetails: User @custom(http: {\n        url:  "https://api.github.com/graphql",\n        method: POST,\n        graphql: "query(username: String!) { user(login: $username) }",\n        skipIntrospection: true\n    })\n}\n')),Object(r.b)("p",null,"Perhaps our app has some measure of their volocity that's calculated by a custom function that looks at both their GitHub commits and some other places where work is added.  Soon we'll have a schema where we can render a user's home page, the projects they work on, their open tickets, their GitHub details, etc. in a single request that queries across multiple sources and can mix Dgraph filtering with external calls."),Object(r.b)("pre",null,Object(r.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'query {\n    getUser(id: "aUser") {\n        username\n        projects(order: { asc: lastUpdate }, first: 10) {\n            projectName\n        }\n        tickets { \n            connectedGitIssue { ... }\n        }\n        velocityMeasure\n        gitDetails { ... }\n        repositories { ... }\n    }\n}\n')),Object(r.b)("hr",null))}u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-doc-custom-field-mdx-cc113be70b82243ecb4f.js.map