{"version":3,"sources":["webpack:///./src/pages/doc/authorization/directive.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","pageContext","frontmatter","title","parentName","isMDXComponent"],"mappings":"gRAMO,IAAMA,EAAe,GAOtBC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,iBAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,sBAAKD,EAAME,YAAYC,YAAYC,OACnC,mFAAkE,0BAAYC,WAAW,KAAvB,SAAlE,iHAAqO,0BAAYA,WAAW,KAAvB,WAArO,8CAAuU,0BAAYA,WAAW,KAAvB,SAAvU,eAAwY,0BAAYA,WAAW,KAAvB,OAAxY,KAA6b,0BAAYA,WAAW,KAAvB,UAA7b,QAAwf,0BAAYA,WAAW,KAAvB,UAAxf,eACA,sCAAqB,0BAAYA,WAAW,KAAvB,SAArB,4cACA,mDACA,6CACA,wEACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,wRAgBL,8CAA6B,0BAAYA,WAAW,KAAvB,QAA7B,mBAAiG,0BAAYA,WAAW,KAAvB,MAAjG,SAAyJ,0BAAYA,WAAW,KAAvB,QAAzJ,wCAAkP,0BAAYA,WAAW,KAAvB,SAAlP,oDAAwV,0BAAYA,WAAW,KAAvB,QAAxV,aAAsZ,0BAAYA,WAAW,KAAvB,SAAtZ,4BACA,4BAAW,0BAAYA,WAAW,KAAvB,SAAX,yDAAsH,0BAAYA,WAAW,KAAvB,iBAAtH,qHACA,kGACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,mEASL,0DAAyC,0BAAYA,WAAW,KAAvB,SAAzC,WAAsG,0BAAYA,WAAW,KAAvB,QAAtG,wDAA+M,0BAAYA,WAAW,KAAvB,SAA/M,qCACA,mCACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,+IASL,qHACA,wMACA,0IAAyH,0BAAYA,WAAW,KAAvB,MAAzH,OAA+K,0BAAYA,WAAW,KAAvB,OAA/K,qHACA,uDACA,gQACA,kGACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,sIAaL,6OACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,sJAUL,sUACA,sHAAqG,0BAAYA,WAAW,KAAvB,QAArG,aAAmK,0BAAYA,WAAW,KAAvB,cAAnK,8BAAwP,0BAAYA,WAAW,KAAvB,QAAxP,KAA8S,0BAAYA,WAAW,KAAvB,OAA9S,oUACA,mDACA,yMACA,6EAA4D,0BAAYA,WAAW,KAAvB,SAA5D,2FAAyM,0BAAYA,WAAW,KAAvB,mBAAzM,iEAAsU,0BAAYA,WAAW,KAAvB,SAAtU,qBACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,qIASL,4FAA2E,0BAAYA,WAAW,KAAvB,QAA3E,0DAAsL,0BAAYA,WAAW,KAAvB,QAAtL,6PAAoe,0BAAYA,WAAW,KAAvB,UAApe,yBACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,mGAQL,2FACA,uCACA,uKACA,6FAA4E,0BAAYA,WAAW,KAAvB,QAA5E,kDACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,mMASL,qCACA,gJACA,2OAA0N,0BAAYA,WAAW,KAAvB,SAA1N,kHACA,wOACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,0LAYL,+GACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,iVAmBL,yIACA,oKAAmJ,0BAAYA,WAAW,KAAvB,6BAAnJ,mBACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,qBADZ,+IASL,uFACA,wBAKJP,EAAWQ,gBAAiB","file":"component---src-pages-doc-authorization-directive-mdx-1155b0b40d6e7a9dff8a.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/debabrata/Sites/Projects/Dgraph/graphql-dgraph-web/src/components/layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1>{props.pageContext.frontmatter.title}</h1>\n    <p>{`Given an authentication mechanism and signed JWT, it's the `}<inlineCode parentName=\"p\">{`@auth`}</inlineCode>{` directive that tells Dgraph how to apply authorization.  The directive can be used on any type (that isn't a `}<inlineCode parentName=\"p\">{`@remote`}</inlineCode>{` type) and specifies the authorization for `}<inlineCode parentName=\"p\">{`query`}</inlineCode>{` as well as `}<inlineCode parentName=\"p\">{`add`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`update`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`delete`}</inlineCode>{` mutations.`}</p>\n    <p>{`In each case, `}<inlineCode parentName=\"p\">{`@auth`}</inlineCode>{` specifies rules that Dgraph applies during queries and mutations.  Those rules are expressed in exactly the same syntax as GraphQL queries.  Why?  Because the authorization you add to your app is about the graph of your application, so graph rules make sense.  It's also the syntax you already know about, you get syntax help from GraphQL tools in writing such rules, and it turns out to be exactly the kinds of rules Dgraph already knows how to evaluate.`}</p>\n    <p>{`Here's how the rules work.`}</p>\n    <h2>{`Authorization rules`}</h2>\n    <p>{`A valid type and rule looks like the following.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Todo @auth(\n    query: { rule: \"\"\"\n        query ($USER: String!) { \n            queryTodo(filter: { owner: { eq: $USER } } ) { \n                id \n            } \n        }\"\"\"\n    }\n){\n    id: ID!\n    text: String! @search(by: [term])\n    owner: String!\n}\n`}</code></pre>\n    <p>{`Here we define a type `}<inlineCode parentName=\"p\">{`Todo`}</inlineCode>{`, that's got an `}<inlineCode parentName=\"p\">{`id`}</inlineCode>{`, the `}<inlineCode parentName=\"p\">{`text`}</inlineCode>{` of the todo and the username of the `}<inlineCode parentName=\"p\">{`owner`}</inlineCode>{` of the todo.  What todos can a user query?  Any `}<inlineCode parentName=\"p\">{`Todo`}</inlineCode>{` that the `}<inlineCode parentName=\"p\">{`query`}</inlineCode>{` rule would also return.`}</p>\n    <p>{`The `}<inlineCode parentName=\"p\">{`query`}</inlineCode>{` rule in this case expects the JWT to contain a claim `}<inlineCode parentName=\"p\">{`\"USER\": \"...\"`}</inlineCode>{` giving the username of the logged in user, and says: you can query any todo that has your username as the owner.`}</p>\n    <p>{`This rule is applied automatically at query time.  For example, the query`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`query {\n    queryTodo {\n        id\n        text\n    }\n}\n`}</code></pre>\n    <p>{`will return only the todo's where `}<inlineCode parentName=\"p\">{`owner`}</inlineCode>{` equals `}<inlineCode parentName=\"p\">{`amit`}</inlineCode>{`, when Amit is logged in and only the todos owned by `}<inlineCode parentName=\"p\">{`nancy`}</inlineCode>{` when she's logged into your app.`}</p>\n    <p>{`Similarly,`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`query {\n    queryTodo(filter: { text: { anyofterms: \"graphql\"}}, first: 10, order: { asc: text }) {\n        id\n        text\n    }\n}\n`}</code></pre>\n    <p>{`will return the first ten todos, ordered ascending by title of the user that made the query.`}</p>\n    <p>{`This means your frontend doesn't need to be sensitive to the auth rules.  Your app can simply query for the todos and that query behaves properly depending on who's logged in.`}</p>\n    <p>{`In general, an auth rule should select a field that's expected to exist at the inner most field, often that's the `}<inlineCode parentName=\"p\">{`ID`}</inlineCode>{` or `}<inlineCode parentName=\"p\">{`@id`}</inlineCode>{` field.  Auth rules are run in a mode that requires all fields in the rule to find a value in order to succeed.  `}</p>\n    <h2>{`Graph traversal in auth rules`}</h2>\n    <p>{`Often authorization depends not on the object being queried, but on the connections in the graph that object has or doesn't have.  Because the auth rules are graph queries, they can express very powerful graph search and traversal.`}</p>\n    <p>{`For a simple todo app, it's more likely that you'll have types like this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type User {\n    username: String! @id\n    todos: [Todo]\n}\n\ntype Todo {\n    id: ID!\n    text: String!\n    owner: User\n}\n`}</code></pre>\n    <p>{`This means your auth rule for todos will depend not on a value in the todo, but on checking which owner it's linked to.  This means our auth rule must make a step further into the graph to check who the owner is.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`query ($USER: String!) { \n    queryTodo {\n        owner(filter: { username: { eq: $USER } } ) { \n            username\n        } \n    } \n}\n`}</code></pre>\n    <p>{`You can express a lot with these kinds of graph traversals.  For example, multitenancy rules can express that you can only see an object if it's linked (through what ever graph search you define) to the organization you were authenticated from.  That means your app can split data per customer easily.`}</p>\n    <p>{`You can also express rules that can be administered by the app itself.  You might define type `}<inlineCode parentName=\"p\">{`Role`}</inlineCode>{` and enum `}<inlineCode parentName=\"p\">{`Privileges`}</inlineCode>{` that can have values like `}<inlineCode parentName=\"p\">{`VIEW`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`ADD`}</inlineCode>{`, etc. and state in your auth rules that a user needs to have a role with particular privileges to query/add/update/delete and those roles can then be allocated inside the app.  For example, in an app about project management, when a project is created the admin can decide which users have view or edit permission, etc.`}</p>\n    <h2>{`Role Based Access Control`}</h2>\n    <p>{`As well as rules that relate a user's claims to a graph traversal, role based access control rules are also possible.  These rules relate a claim in the JWT to a known value.  `}</p>\n    <p>{`For example, perhaps only someone logged in with the `}<inlineCode parentName=\"p\">{`ADMIN`}</inlineCode>{` role is allowed to delete users.  For that, we might expect the JWT to contain a claim `}<inlineCode parentName=\"p\">{`\"ROLE\": \"ADMIN\"`}</inlineCode>{`, and can thus express a rule that only allows users with the `}<inlineCode parentName=\"p\">{`ADMIN`}</inlineCode>{` claim to delete.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type User @auth(\n    delete: { rule:  \"{$ROLE: { eq: \\\\\"ADMIN\\\\\" } }\"}\n) { \n    username: String! @id\n    todos: [Todo]\n}\n`}</code></pre>\n    <p>{`Not all claims need to be present in all JWTs.  For example, if the `}<inlineCode parentName=\"p\">{`ROLE`}</inlineCode>{` claim isn't present in a JWT, any rule that relies on `}<inlineCode parentName=\"p\">{`ROLE`}</inlineCode>{` simply evaluates to false.  As well as simplifying your JWTs (e.g. not all users need a role if it doesn't make sense to do so), this means you can also simply disallow some queries and mutations.  If you know that your JWTs never contain the claim `}<inlineCode parentName=\"p\">{`DENIED`}</inlineCode>{`, then a rule such as`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type User @auth(\n    delete: { rule:  \"{$DENIED: { eq: \\\\\"DENIED\\\\\" } }\"}\n) { \n    ...\n}\n`}</code></pre>\n    <p>{`can never be true and this would prevent users ever being deleted.`}</p>\n    <h2>{`and, or & not`}</h2>\n    <p>{`Rules can be combined with the logical connectives and, or and not, so a permission can be a mixture of graph traversals and role based rules.`}</p>\n    <p>{`In the todo app, you can express, for example, that you can delete a `}<inlineCode parentName=\"p\">{`Todo`}</inlineCode>{` if you are the author, or are the site admin.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Todo @auth(\n    delete: { or: [ \n        { rule:  \"query ($USER: String!) { ... }\" }, # you are the author graph query\n        { rule:  \"{$ROLE: { eq: \\\\\"ADMIN\\\\\" } }\" }\n    ]}\n)\n`}</code></pre>\n    <h2>{`Public Data`}</h2>\n    <p>{`Many apps have data that can be accessed by anyone, logged in or not.  That also works nicely with Dgraph auth rules.  `}</p>\n    <p>{`For example, in Twitter, StackOverflow, etc. you can see authors and posts without being signed it - but you'd need to be signed in to add a post.  With Dgraph auth rules, if a type doesn't have, for example, a `}<inlineCode parentName=\"p\">{`query`}</inlineCode>{` auth rule or the auth rule doesn't depend on a JWT value, then the data can be accessed without a signed JWT.`}</p>\n    <p>{`For example, the todo app might allow anyone, logged in or not, to view any author, but not make any mutations unless logged in as the author or an admin.  That would be achieved by rules like the following.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type User @auth(\n    # no query rule\n    add: { rule:  \"{$ROLE: { eq: \\\\\"ADMIN\\\\\" } }\" },\n    update: ...\n    delete: ...\n) {\n    username: String! @id\n    todos: [Todo]\n}\n`}</code></pre>\n    <p>{`Maybe some todos can be marked as public and users you aren't logged in can see those.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Todo @auth(\n    query: { or: [\n        # you are the author \n        { rule: ... },\n        # or, the todo is marked as public\n        { rule: \"\"\"query { \n            queryTodo(filter: { isPublic: { eq: true } } ) { \n                id \n            } \n        }\"\"\"}\n    ]}\n) { \n    ...\n    isPublic: Boolean\n}\n\n`}</code></pre>\n    <p>{`Because the rule doesn't depend on a JWT value, it can be successfully evaluated for users who aren't logged in.`}</p>\n    <p>{`Ensuring that requests are from an authenticated JWT, and no further restrictions, can be done by arranging the JWT to contain a value like `}<inlineCode parentName=\"p\">{`\"isAuthenticated\": \"true\"`}</inlineCode>{`.  For example,`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type User @auth(\n    query: { rule:  \"{$isAuthenticated: { eq: \\\\\"true\\\\\" } }\" },\n) {\n    username: String! @id\n    todos: [Todo]\n}\n`}</code></pre>\n    <p>{`specifies that only authenticated users can query other users.`}</p>\n    <hr></hr>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}