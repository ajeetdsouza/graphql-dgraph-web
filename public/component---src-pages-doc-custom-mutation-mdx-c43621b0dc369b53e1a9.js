(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{E4x0:function(t,e,n){"use strict";n.r(e),n.d(e,"_frontmatter",(function(){return i})),n.d(e,"default",(function(){return u}));n("rzGZ"),n("Dq+y"),n("8npG"),n("Ggvi"),n("E5k/"),n("q1tI");var a=n("7ljp"),o=n("Bl7J");var i={},s={_frontmatter:i},r=o.a;function u(t){var e=t.components,n=function(t,e){if(null==t)return{};var n,a,o={},i=Object.keys(t);for(a=0;a<i.length;a++)n=i[a],e.indexOf(n)>=0||(o[n]=t[n]);return o}(t,["components"]);return Object(a.b)(r,Object.assign({},s,n,{components:e,mdxType:"MDXLayout"}),Object(a.b)("h1",null,n.pageContext.frontmatter.title),Object(a.b)("p",null,"Let's say we have an application about authors and posts.  Logged in authors can add posts, but we want to do some input validation and add extra value when a post is added.  The key types might be as follows."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),"type Author { ... }\n\ntype Post {\n    id: ID:\n    title: String\n    text: String\n    datePublished: DateTime\n    author: Author\n    ...\n}\n")),Object(a.b)("p",null,"Dgraph generates an ",Object(a.b)("inlineCode",{parentName:"p"},"addPost")," mutation from those types, but we want to do something extra.  We don't want the ",Object(a.b)("inlineCode",{parentName:"p"},"author")," to come in with the mutation, that should get filled in from the JWT of the logged in user.  Also, the ",Object(a.b)("inlineCode",{parentName:"p"},"datePublished")," shouldn't be in the input; it should be set as the current time at point of mutation.  Maybe we also have some community guidelines about what might constitute an offensive ",Object(a.b)("inlineCode",{parentName:"p"},"title")," or ",Object(a.b)("inlineCode",{parentName:"p"},"text")," in a post. Maybe users can only post if they have enough community credit."),Object(a.b)("p",null,"We'll need custom code to do all that, so we can write a custom function that takes in only the title and text of the new post.  Internally, it can check that the title and text satisfy the guidelines and that this user has enough credit to make a post. If those checks pass, it then builds a full post object by adding the current time as the ",Object(a.b)("inlineCode",{parentName:"p"},"datePublished")," and adding the ",Object(a.b)("inlineCode",{parentName:"p"},"author")," from the JWT information it gets from the forward header.  It can then call the ",Object(a.b)("inlineCode",{parentName:"p"},"addPost")," mutation constructed by Dgraph to add the post into Dgraph and returns the resulting post as its GraphQL output."),Object(a.b)("p",null,"So as well as the types above, we need a custom mutation:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type Mutation {\n    newPost(title: String!, text: String): Post @custom(http:{\n        url: "https://my.api.com/addPost"\n        method: "POST",\n        body: "{ postText: $text, postTitle: $title }"\n        forwardHeaders: ["AuthHdr"]\n    })\n}\n')),Object(a.b)("p",null,"(Note: there's more docs coming about turning off the generated mutations, protecting them with authorization rules etc.)"),Object(a.b)("hr",null))}u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-doc-custom-mutation-mdx-c43621b0dc369b53e1a9.js.map