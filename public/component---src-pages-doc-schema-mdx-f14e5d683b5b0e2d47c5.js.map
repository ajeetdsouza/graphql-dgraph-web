{"version":3,"sources":["webpack:///./src/pages/doc/schema.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","pageContext","frontmatter","title","parentName","name","isMDXComponent"],"mappings":"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","file":"component---src-pages-doc-schema-mdx-f14e5d683b5b0e2d47c5.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/Users/debabrata/Sites/Projects/Dgraph/graphql-dgraph-web/src/components/layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1>{props.pageContext.frontmatter.title}</h1>\n    <p>{`All the things you can put in your input GraphQL schema, and what gets generated from that.`}</p>\n    <p>{`The process for serving GraphQL with Dgraph is to add a set of GraphQL type definitions using the `}<inlineCode parentName=\"p\">{`/admin`}</inlineCode>{` endpoint.  Dgraph takes those definitions, generates queries and mutations, and serves the generated GraphQL schema.  `}</p>\n    <p>{`The input schema may only contain interfaces, types and enums that follow the usual GraphQL syntax and validation rules.  Additional validation rules are called out below.`}</p>\n    <p>{`If you want to make your schema editing experience nicer, you should use an editor that does syntax highlighting for GraphQL.  With that, you may also want to include the definitions `}<a parentName=\"p\" {...{\n        \"href\": \"#schemafragment\"\n      }}>{`here`}</a>{` as an import.`}</p>\n    <h1><a name=\"Scalars\"></a>{`Scalars`}</h1>\n    <p>{`Dgraph GraphQL comes with the standard GraphQL scalars: `}<inlineCode parentName=\"p\">{`Int`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`Float`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`String`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`Boolean`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`ID`}</inlineCode>{`.  There's also a `}<inlineCode parentName=\"p\">{`DateTime`}</inlineCode>{` scalar - represented as a string in RFC3339 format.`}</p>\n    <p>{`Scalars `}<inlineCode parentName=\"p\">{`Int`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`Float`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`String`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`DateTime`}</inlineCode>{` can be used in lists.  All scalars may be nullable or non-nullable.`}</p>\n    <p>{`The `}<inlineCode parentName=\"p\">{`ID`}</inlineCode>{` type is special.  IDs are auto-generated, immutable, and can be treated as strings.  Fields of type `}<inlineCode parentName=\"p\">{`ID`}</inlineCode>{` can be listed as nullable in a schema, but Dgraph will never return null. `}</p>\n    <ul>\n      <li parentName=\"ul\"><em parentName=\"li\">{`Schema rule`}</em>{`: `}<inlineCode parentName=\"li\">{`ID`}</inlineCode>{` lists aren't allowed - e.g. `}<inlineCode parentName=\"li\">{`tags: [String]`}</inlineCode>{` is valid, but `}<inlineCode parentName=\"li\">{`ids: [ID]`}</inlineCode>{` is not.`}</li>\n      <li parentName=\"ul\"><em parentName=\"li\">{`Schema rule`}</em>{`: Each type you define can have at most one field with type `}<inlineCode parentName=\"li\">{`ID`}</inlineCode>{`.  That includes IDs implemented through interfaces.`}</li>\n    </ul>\n    <p>{`It's not possible to define further scalars - you'll receive an error if the input schema contains the definition of a new scalar.`}</p>\n    <p>{`For example, the following GraphQL type uses all of the available scalars.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type User {\n    userID: ID!\n    name: String!\n    lastSignIn: DateTime\n    recentScores: [Float]\n    reputation: Int\n    active: Boolean\n}\n`}</code></pre>\n    <p>{`Scalar lists in Dgraph act more like sets, so `}<inlineCode parentName=\"p\">{`tags: [String]`}</inlineCode>{` would always contain unique tags.  Similarly, `}<inlineCode parentName=\"p\">{`recentScores: [Float]`}</inlineCode>{` could never contain duplicate scores.`}</p>\n    <h1><a name=\"Enums\"></a>{`Enums`}</h1>\n    <p>{`You can define enums in your input schema.  For example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`enum Tag {\n    GraphQL\n    Database\n    Question\n    ...\n}\n\ntype Post {\n    ...\n    tags: [Tag!]!\n}\n`}</code></pre>\n    <h1><a name=\"Types\"></a>{`Types`}</h1>\n    <p>{`From the built-in scalars and the enums you add, you can generate types in the usual way for GraphQL.  For example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`enum Tag {\n    GraphQL\n    Database\n    Dgraph\n}\n\ntype Post {\n    id: ID!\n    title: String!\n    text: String\n    datePublished: DateTime\n    tags: [Tag!]!\n    author: Author!\n}\n\ntype Author {\n    id: ID!\n    name: String!\n    posts: [Post!]\n    friends: [Author]\n}\n`}</code></pre>\n    <ul>\n      <li parentName=\"ul\"><em parentName=\"li\">{`Schema rule`}</em>{`: Lists of lists aren't accepted.  For example: `}<inlineCode parentName=\"li\">{`multiTags: [[Tag!]]`}</inlineCode>{` isn't valid.`}</li>\n      <li parentName=\"ul\"><em parentName=\"li\">{`Schema rule`}</em>{`: Fields with arguments are not accepted in the input schema.`}</li>\n    </ul>\n    <h1><a name=\"Interfaces\"></a>{`Interfaces`}</h1>\n    <p>{`GraphQL interfaces allow you to define a generic pattern that multiple types follow.  When a type implements an interface, that means it has all fields of the interface and some extras.  `}</p>\n    <p>{`When a type implements an interface, GraphQL requires that the type repeats all the fields from the interface, but that's just boilerplate and a maintenance problem, so Dgraph doesn't need that repetition in the input schema and will generate the correct GraphQL for you.`}</p>\n    <p>{`For example, the following defines the schema for posts with comment threads; Dgraph will fill in the `}<inlineCode parentName=\"p\">{`Question`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Comment`}</inlineCode>{` types to make the full GraphQL types.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`interface Post {\n    id: ID!\n    text: String\n    datePublished: DateTime\n}\n\ntype Question implements Post {\n    title: String!\n}\n\ntype Comment implements Post {\n    commentsOn: Post!\n}\n`}</code></pre>\n    <p>{`The generated GraphQL will contain the full types, for example, `}<inlineCode parentName=\"p\">{`Question`}</inlineCode>{` gets expanded as:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Question implements Post {\n    id: ID!\n    text: String\n    datePublished: DateTime\n    title: String!\n}\n`}</code></pre>\n    <p>{`while `}<inlineCode parentName=\"p\">{`Comment`}</inlineCode>{` gets expanded as:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Comment implements Post {\n    id: ID!\n    text: String\n    datePublished: DateTime\n    commentsOn: Post!\n}\n`}</code></pre>\n    <h1><a name=\"Directives\"></a>{`Directives`}</h1>\n    <p>{`Dgraph uses the types and fields in the schema to work out what to accept for mutations and what shape responses should take.  Dgraph also defines a set of GraphQL directives that it uses to further refine what services the GraphQL API offers.  In particular, how to handle two-way edges and what search capability to build in.`}</p>\n    <h2><a name=\"Inverse\"></a>{`Inverse Edges`}</h2>\n    <p>{`GraphQL schemas are always under-specified in that`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Author {\n    ...\n    posts: [Post]\n}\n\ntype Post {\n    ...\n    author: Author\n}\n`}</code></pre>\n    <p>{`says that an author has a list of posts and a post has an author, but it doesn't tell us that every post in the list of posts for an author has that author as their `}<inlineCode parentName=\"p\">{`author`}</inlineCode>{`.  In GraphQL, it's left up to the implementation to make the two-way connection.  Here, we'd expect an author to be the author of all their posts, but that's not what GraphQL enforces.`}</p>\n    <p>{`There's not always a two-way edge. Consider if `}<inlineCode parentName=\"p\">{`Author`}</inlineCode>{` were defined as:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Author {\n    ...\n    posts: [Post]\n    liked: [Post]\n}\n`}</code></pre>\n    <p>{`There should be no two-way edge for `}<inlineCode parentName=\"p\">{`liked`}</inlineCode>{`.  `}</p>\n    <p>{`In Dgraph, the directive `}<inlineCode parentName=\"p\">{`@hasInverse`}</inlineCode>{` is used to sort out which edges are bi-directional and which aren't. Adding`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Author {\n    ...\n    posts: [Post] @hasInverse(field: author)\n    liked: [Post]\n}\n\ntype Post {\n    ...\n    author: Author @hasInverse(field: posts)\n}\n`}</code></pre>\n    <p>{`tells Dgraph to link `}<inlineCode parentName=\"p\">{`posts`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`author`}</inlineCode>{`.  When a new post is added Dgraph ensures that it's also in the list of its author's posts.  Field   `}<inlineCode parentName=\"p\">{`liked`}</inlineCode>{`, on the other hand, has no such linking.`}</p>\n    <h2><a name=\"Search\"></a>{`Search`}</h2>\n    <p>{`The `}<inlineCode parentName=\"p\">{`@search`}</inlineCode>{` directive tells Dgraph what search to build into your API.`}</p>\n    <p>{`When a type contains an `}<inlineCode parentName=\"p\">{`@search`}</inlineCode>{` directive, Dgraph constructs a search input type and a query in the GraphQL `}<inlineCode parentName=\"p\">{`Query`}</inlineCode>{` type. For example, if the schema contains`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type post {\n    ...\n    text: Int @search(by: [term])\n}\n`}</code></pre>\n    <p>{`then, Dgraph constructs an input type `}<inlineCode parentName=\"p\">{`PostFilter`}</inlineCode>{` and adds all possible search options for posts to that.  The search options it constructs are different for each type and argument to `}<inlineCode parentName=\"p\">{`@search`}</inlineCode>{` as explained below.`}</p>\n    <h3>{`Int, Float and DateTime`}</h3>\n    <p>{`Search for fields of types `}<inlineCode parentName=\"p\">{`Int`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`Float`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`DateTime`}</inlineCode>{` is enabled by adding `}<inlineCode parentName=\"p\">{`@search`}</inlineCode>{` to the field.  For example, if a schema contains:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Post {\n    ...\n    numLikes: Int @search\n}\n`}</code></pre>\n    <p>{`Dgraph generates search into the API for `}<inlineCode parentName=\"p\">{`numLikes`}</inlineCode>{` in two ways: a query for posts and field search on any post list.`}</p>\n    <p>{`A field `}<inlineCode parentName=\"p\">{`queryPost`}</inlineCode>{` is added to the `}<inlineCode parentName=\"p\">{`Query`}</inlineCode>{` type of the schema.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`queryPost(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`PostFilter`}</inlineCode>{` will contain less than `}<inlineCode parentName=\"p\">{`lt`}</inlineCode>{`, less than or equal to `}<inlineCode parentName=\"p\">{`le`}</inlineCode>{`, equal `}<inlineCode parentName=\"p\">{`eq`}</inlineCode>{`, greater than or equal to `}<inlineCode parentName=\"p\">{`ge`}</inlineCode>{` and greater than `}<inlineCode parentName=\"p\">{`gt`}</inlineCode>{` search on `}<inlineCode parentName=\"p\">{`numLikes`}</inlineCode>{`.  Allowing for example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`queryPost(filter: { numLikes: { gt: 50 }}) { ... }\n`}</code></pre>\n    <p>{`Also, any field with a type of list of posts has search options added to it. For example, if the input schema also contained:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Author {\n    ...\n    posts: [Post]\n}\n`}</code></pre>\n    <p>{`Dgraph would insert search into `}<inlineCode parentName=\"p\">{`posts`}</inlineCode>{`, with`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Author {\n    ...\n    posts(filter: PostFilter, order: PostOrder, first: Int, offset: Int): [Post]\n}\n`}</code></pre>\n    <p>{`That allows search within the GraphQL query.  For example, to find Karthic's posts with more than 50 likes.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`queryAuthor(filter: { name: { eq: \"Karthic\" } } ) {\n    ...\n    posts(filter: { numLikes: { gt: 50 }}) {\n        title\n        text\n    }\n}\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`DateTime`}</inlineCode>{` also allows specifying how the search index should be built: by year, month, day or hour.  `}<inlineCode parentName=\"p\">{`@search`}</inlineCode>{` defaults to year, but once you understand your data and query patterns, you might want to changes that like `}<inlineCode parentName=\"p\">{`@search(by: [day])`}</inlineCode>{`.`}</p>\n    <h3>{`Boolean`}</h3>\n    <p>{`Booleans can only be tested for true or false.  If `}<inlineCode parentName=\"p\">{`isActiveMember: Boolean @search`}</inlineCode>{` is in the schema, then the search allows`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`filter: { isPublished: true }\n`}</code></pre>\n    <p>{`and`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`filter: { isPublished: false }\n`}</code></pre>\n    <h3>{`String`}</h3>\n    <p>{`Strings allow a wider variety of search options than other types.  For strings, you have the following options as arguments to `}<inlineCode parentName=\"p\">{`@search`}</inlineCode>{`.`}</p>\n    <table>\n      <thead parentName=\"table\">\n        <tr parentName=\"thead\">\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`argument`}</th>\n          <th parentName=\"tr\" {...{\n            \"align\": null\n          }}>{`constructed searches`}</th>\n        </tr>\n      </thead>\n      <tbody parentName=\"table\">\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}><inlineCode parentName=\"td\">{`hash`}</inlineCode></td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}><inlineCode parentName=\"td\">{`eq`}</inlineCode></td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}><inlineCode parentName=\"td\">{`exact`}</inlineCode></td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}><inlineCode parentName=\"td\">{`lt`}</inlineCode>{`, `}<inlineCode parentName=\"td\">{`le`}</inlineCode>{`, `}<inlineCode parentName=\"td\">{`eq`}</inlineCode>{`, `}<inlineCode parentName=\"td\">{`ge`}</inlineCode>{` and `}<inlineCode parentName=\"td\">{`gt`}</inlineCode>{` (lexicographically)`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}><inlineCode parentName=\"td\">{`regexp`}</inlineCode></td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}><inlineCode parentName=\"td\">{`regexp`}</inlineCode>{` (regular expressions)`}</td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}><inlineCode parentName=\"td\">{`term`}</inlineCode></td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}><inlineCode parentName=\"td\">{`allofterms`}</inlineCode>{` and `}<inlineCode parentName=\"td\">{`anyofterms`}</inlineCode></td>\n        </tr>\n        <tr parentName=\"tbody\">\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}><inlineCode parentName=\"td\">{`fulltext`}</inlineCode></td>\n          <td parentName=\"tr\" {...{\n            \"align\": null\n          }}><inlineCode parentName=\"td\">{`alloftext`}</inlineCode>{` and `}<inlineCode parentName=\"td\">{`anyoftext`}</inlineCode></td>\n        </tr>\n      </tbody>\n    </table>\n    <ul>\n      <li parentName=\"ul\"><em parentName=\"li\">{`Schema rule`}</em>{`: `}<inlineCode parentName=\"li\">{`hash`}</inlineCode>{` and `}<inlineCode parentName=\"li\">{`exact`}</inlineCode>{` can't be used together.`}</li>\n    </ul>\n    <p>{`Exact and hash search have the standard lexicographic meaning. Search by regular expression requires bracketing the expression with `}<inlineCode parentName=\"p\">{`/`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`/`}</inlineCode>{`.  For example, query for \"Karthic\" and anyone else with \"rti\" in their name:`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`queryAuthor(filter: { name: { regexp: \"/.*rti.*/\" } }) { ... }\n`}</code></pre>\n    <p>{`If the schema has `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Post {\n    title: String @search(by: [term])\n    text: String @search(by: [fulltext])\n    ...\n}\n`}</code></pre>\n    <p>{`then `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`queryPost(filter: { title: { \\`allofterms: \"GraphQL tutorial\"\\` } } ) { ... }\n`}</code></pre>\n    <p>{`will match all posts with both \"GraphQL and \"tutorial\" in the title, while `}<inlineCode parentName=\"p\">{`anyofterms: \"GraphQL tutorial\"`}</inlineCode>{` would match posts with either \"GraphQL\" or \"tutorial\".`}</p>\n    <p><inlineCode parentName=\"p\">{`fulltext`}</inlineCode>{` search is Google-stye text search with stop words, stemming. etc.  So `}<inlineCode parentName=\"p\">{`alloftext: \"run woman\"`}</inlineCode>{` would match \"run\" as well as \"running\", etc.  For example, to find posts that talk about fantastic GraphQL tutorials:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`queryPost(filter: { title: { \\`alloftext: \"fantastic GraphQL tutorials\"\\` } } ) { ... }\n`}</code></pre>\n    <p>{`It's possible to add multiple string indexes to a field.  For example to search for authors by `}<inlineCode parentName=\"p\">{`eq`}</inlineCode>{` and regular expressions, add both options to the type definition, as follows.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type Author {\n    ...\n    name: String! @search(by: [hash, regexp])\n}\n`}</code></pre>\n    <h3>{`Enums`}</h3>\n    <p>{`Enums are serialized in Dgraph as strings.  `}<inlineCode parentName=\"p\">{`@search`}</inlineCode>{` with no arguments is the same as `}<inlineCode parentName=\"p\">{`@search(by: [hash])`}</inlineCode>{` and provides only `}<inlineCode parentName=\"p\">{`eq`}</inlineCode>{` search.  Also available for enums are `}<inlineCode parentName=\"p\">{`exact`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`regexp`}</inlineCode>{`.  For hash and exact search on enums, the literal enum value, without quotes `}<inlineCode parentName=\"p\">{`\"...\"`}</inlineCode>{`, is used, for regexp, strings are required. For example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`enum Tag {\n    GraphQL\n    Database\n    Question\n    ...\n}\n\ntype Post {\n    ...\n    tags: [Tag!]! @search\n}\n`}</code></pre>\n    <p>{`would allow`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`queryPost(filter: { tags: { eq: GraphQL } } ) { ... }\n`}</code></pre>\n    <p>{`Which would find any post with the `}<inlineCode parentName=\"p\">{`GraphQL`}</inlineCode>{` tag.`}</p>\n    <p>{`While `}<inlineCode parentName=\"p\">{`@search(by: [exact, regexp]`}</inlineCode>{` would also admit `}<inlineCode parentName=\"p\">{`lt`}</inlineCode>{` etc. and `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`queryPost(filter: { tags: { regexp: \"/.*aph.*/\" } } ) { ... }\n`}</code></pre>\n    <p>{`which is helpful for example if the enums are something like product codes where regular expressions can match a number of values. `}</p>\n    <h3>{`and, or, and not`}</h3>\n    <p>{`Every search filter contains `}<inlineCode parentName=\"p\">{`and`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`or`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`not`}</inlineCode>{`.`}</p>\n    <p>{`GraphQL's syntax is used to write these infix style, so \"a and b\" is written `}<inlineCode parentName=\"p\">{`a, and: { b }`}</inlineCode>{`, and \"a or b or c\" is written `}<inlineCode parentName=\"p\">{`a, or: { b, or: c }`}</inlineCode>{`.  Not is written prefix.`}</p>\n    <p>{`The posts that do not have \"GraphQL\" in the title.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`queryPost(filter: { not: { title: { allofterms: \"GraphQL\"} } } ) { ... }\n`}</code></pre>\n    <p>{`The posts that have \"GraphQL\" or \"Dgraph\" in the title.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`queryPost(filter: { \n    title: { allofterms: \"GraphQL\"},\n    or: { title: { allofterms: \"Dgraph\" } } \n  } ) { ... }\n`}</code></pre>\n    <p>{`The posts that have \"GraphQL\" and \"Dgraph\" in the title.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`queryPost(filter: { \n    title: { allofterms: \"GraphQL\"},\n    and: { title: { allofterms: \"Dgraph\" } } \n  } ) { ... }\n`}</code></pre>\n    <p>{`The and is implicit for a single filter object.  The above could be written equivalently as:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`queryPost(filter: { \n    title: { allofterms: \"GraphQL\"},\n    title: { allofterms: \"Dgraph\" } \n  } ) { ... }\n`}</code></pre>\n    <p>{`The posts that have \"GraphQL\" in the title, or have the tag \"GraphQL\" and mention \"Dgraph\" in the title`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`queryPost(filter: { \n    title: { allofterms: \"GraphQL\"},\n    or: { title: { allofterms: \"Dgraph\" }, tags: { eg: \"GraphQL\" } }\n  } ) { ... }\n`}</code></pre>\n    <h3>{`Order and Pagination`}</h3>\n    <p>{`Every type with fields whose types can be ordered (`}<inlineCode parentName=\"p\">{`Int`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`Float`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`String`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`DateTime`}</inlineCode>{`) gets ordering built into the query and any list fields of that type.  Every query and list field gets pagination with `}<inlineCode parentName=\"p\">{`first`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`after`}</inlineCode>{`.`}</p>\n    <p>{`For example, find the most recent 5 posts.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`queryPost(order: { desc: datePublished }, first: 5) { ... }\n`}</code></pre>\n    <p>{`It's also possible to give multiple orders.  For example, sort by date and within each date order the posts by number of likes.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`queryPost(order: { desc: datePublished, then: { desc: numLikes } }, first: 5) { ... }\n`}</code></pre>\n    <h1><a name=\"schemafragment\"></a>{`Dgraph Schema Fragment`}</h1>\n    <p>{`While editing your schema, you might find it useful to include this GraphQL schema fragment.  It sets up the definitions of the directives, etc. (like `}<inlineCode parentName=\"p\">{`@search`}</inlineCode>{`) that you'll use in your schema.  If your editor is GraphQL aware, it will give you errors if you don't have this available.`}</p>\n    <p>{`Don't include it in your input schema to Dgraph - use your editing environment to set it up as an import.  The details will depend on your setup.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`scalar DateTime\n\ndirective @hasInverse(field: String!) on FIELD_DEFINITION\ndirective @search(by: [DgraphIndex!]) on FIELD_DEFINITION\n\nenum DgraphIndex {\n  int\n  float\n  bool\n  hash\n  exact\n  term\n  fulltext\n  trigram\n  regexp\n  year\n  month\n  day\n  hour\n}\n`}</code></pre>\n    <h1>{`Reserved Names`}</h1>\n    <p>{`Names `}<inlineCode parentName=\"p\">{`Int`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`Float`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`Boolean`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`String`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`DateTime`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`ID`}</inlineCode>{` are reserved and cannot be used to define any other identifiers.`}</p>\n    <p>{`For each type, Dgraph generates a number of GraphQL types needed to operate the GraphQL API, these generated type names also can't be present in the input schema.  For example, for a type `}<inlineCode parentName=\"p\">{`Author`}</inlineCode>{`, Dgraph generates `}<inlineCode parentName=\"p\">{`AuthorFilter`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`AuthorOrderable`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`AuthorOrder`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`AuthorRef`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`AddAuthorInput`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`UpdateAuthorInput`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`AuthorPatch`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`AddAuthorPayload`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`DeleteAuthorPayload`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`UpdateAuthorPayload`}</inlineCode>{`.  Thus if `}<inlineCode parentName=\"p\">{`Author`}</inlineCode>{` is present in the input schema, all of those become reserved type names.`}</p>\n    <h1>{`GraphQL Error Propagation`}</h1>\n    <p>{`Before returning query and mutation results, Dgraph uses the types in the schema to apply GraphQL `}<a parentName=\"p\" {...{\n        \"href\": \"https://graphql.github.io/graphql-spec/June2018/#sec-Value-Completion\"\n      }}>{`value completion`}</a>{` and `}<a parentName=\"p\" {...{\n        \"href\": \"https://graphql.github.io/graphql-spec/June2018/#sec-Errors-and-Non-Nullability\"\n      }}>{`error handling`}</a>{`.  That is, `}<inlineCode parentName=\"p\">{`null`}</inlineCode>{` values for non-nullable fields, e.g. `}<inlineCode parentName=\"p\">{`String!`}</inlineCode>{`, cause error propagation to parent fields.  `}</p>\n    <p>{`In short, the GraphQL value completion and error propagation mean the following.`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Fields marked as nullable (i.e. without `}<inlineCode parentName=\"li\">{`!`}</inlineCode>{`) can return `}<inlineCode parentName=\"li\">{`null`}</inlineCode>{` in the json response.`}</li>\n      <li parentName=\"ul\">{`For fields marked as non-nullable (i.e. with `}<inlineCode parentName=\"li\">{`!`}</inlineCode>{`) Dgraph never returns null for that field.`}</li>\n      <li parentName=\"ul\">{`If an instance of type has a non-nullable field that has evaluated to null, the whole instance results in null.`}</li>\n      <li parentName=\"ul\">{`Reducing an object to null might cause further error propagation.  For example, querying for a post that has an author with a null name results in null: the null name (`}<inlineCode parentName=\"li\">{`name: String!`}</inlineCode>{`) causes the author to result in null, and a null author causes the post (`}<inlineCode parentName=\"li\">{`author: Author!`}</inlineCode>{`) to result in null.`}</li>\n      <li parentName=\"ul\">{`Error propagation for lists with nullable elements, e.g. `}<inlineCode parentName=\"li\">{`friends [Author]`}</inlineCode>{`, can result in nulls inside the result list.`}</li>\n      <li parentName=\"ul\">{`Error propagation for lists with non-nullable elements results in null for `}<inlineCode parentName=\"li\">{`friends [Author!]`}</inlineCode>{` and would cause further error propagation for `}<inlineCode parentName=\"li\">{`friends [Author!]!`}</inlineCode>{`.`}</li>\n    </ul>\n    <p>{`Note that, a query that results in no values for a list will always return the empty list `}<inlineCode parentName=\"p\">{`[]`}</inlineCode>{`, not `}<inlineCode parentName=\"p\">{`null`}</inlineCode>{`, regardless of the nullability.  For example, given a schema for an author with `}<inlineCode parentName=\"p\">{`posts: [Post!]!`}</inlineCode>{`, if an author has not posted anything and we queried for that author, the result for the posts field would be `}<inlineCode parentName=\"p\">{`posts: []`}</inlineCode>{`.  `}</p>\n    <p>{`A list can, however, result in null due to GraphQL error propagation.  For example, if the definition is `}<inlineCode parentName=\"p\">{`posts: [Post!]`}</inlineCode>{`, and we queried for an author who has a list of posts.  If one of those posts happened to have a null title (title is non-nullable `}<inlineCode parentName=\"p\">{`title: String!`}</inlineCode>{`), then that post would evaluate to null, the `}<inlineCode parentName=\"p\">{`posts`}</inlineCode>{` list can't contain nulls and so the list reduces to null.`}</p>\n    <h1>{`What's to come for Dgraph GraphQL`}</h1>\n    <p>{`Dgraph's GraphQL features are in active development.  On the way soon are more search features as well as better mutations.  Also, expect to see GraphQL subscriptions and authorization and authentication features built in.  For existing Dgraph users, we'll be adding features to boot your existing schema into GraphQL and ways you can define your own queries backed by whatever GraphQL+- you like.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}