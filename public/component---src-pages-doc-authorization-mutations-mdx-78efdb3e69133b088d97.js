(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{m9Bp:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return r})),n.d(t,"default",(function(){return u}));n("rzGZ"),n("Dq+y"),n("8npG"),n("Ggvi"),n("E5k/"),n("q1tI");var a=n("7ljp"),o=n("Bl7J");var r={},l={_frontmatter:r},s=o.a;function u(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,["components"]);return Object(a.b)(s,Object.assign({},l,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",null,n.pageContext.frontmatter.title),Object(a.b)("p",null,"Mutations with auth work similarly to query.  However, mutations involve a state change in the database, so it's important to understand when the rules are applied and what they mean."),Object(a.b)("h2",null,"Add"),Object(a.b)("p",null,"Rules for ",Object(a.b)("inlineCode",{parentName:"p"},"add")," authorization state that the rule must hold of nodes created by the mutation data once committed to the database."),Object(a.b)("p",null,"For example, a rule such as:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type Todo @auth(\n    add: { rule: """\n        query ($USER: String!) { \n            queryTodo {\n                owner(filter: { username: { eq: $USER } } ) { \n                    username\n                } \n            } \n        }"""\n    }\n){{\n    id: ID!\n    text: String!\n    owner: User\n}\n\ntype User {\n    username: String! @id\n    todos: [Todo]\n}\n')),Object(a.b)("p",null,"states that if you add a new todo, then that new todo must be a todo that satisfies the ",Object(a.b)("inlineCode",{parentName:"p"},"add")," rule, in this case saying that you can only add todos with yourself as the author."),Object(a.b)("h2",null,"Delete"),Object(a.b)("p",null,"Delete rules filter the nodes that can be deleted.  A user can only ever delete a subset of the nodes that the ",Object(a.b)("inlineCode",{parentName:"p"},"delete")," rules allow.  "),Object(a.b)("p",null,"For example, this rule states that a user can delete a todo if they own it, or they have the ",Object(a.b)("inlineCode",{parentName:"p"},"ADMIN")," role."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type Todo @auth(\n    delete: { or: [ \n        { rule: """\n            query ($USER: String!) { \n                queryTodo {\n                    owner(filter: { username: { eq: $USER } } ) { \n                        username\n                    } \n                } \n            }"""\n        },\n        { rule:  "{$ROLE: { eq: \\"ADMIN\\" } }"}\n    ]}\n){{\n    id: ID!\n    text: String! @search(by: [term])\n    owner: User\n}\n\ntype User {\n    username: String! @id\n    todos: [Todo]\n}\n')),Object(a.b)("p",null,"So a mutation like:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'mutation {\n    deleteTodo(filter: { text: { anyofterms: "graphql" } }) {\n        numUids    \n    }\n}\n')),Object(a.b)("p",null,'for most users would delete their own posts that contain the term "graphql", but wouldn\'t affect any other user\'s todos; for an admin, it would delete any users posts that contain "graphql"'),Object(a.b)("p",null,"For add, what matters is the resulting state of the database, for delete it's the state before the delete occurs."),Object(a.b)("h2",null,"Update"),Object(a.b)("p",null,"Updates have both a before and after state that can be important for auth.  "),Object(a.b)("p",null,"For example, consider a rule stating that you can only update your own todos.  If evaluated in the database before the mutation, like the delete rules, it would prevent you updating anyone elses todos, but does it stop you updating your own todo to have a different ",Object(a.b)("inlineCode",{parentName:"p"},"owner"),".  If evaluated in the database after the mutation occurs, like for add rules, it would stop setting the ",Object(a.b)("inlineCode",{parentName:"p"},"owner")," to another user, but would it prevent editing other's posts."),Object(a.b)("p",null,"Currently, Dgraph evaluates ",Object(a.b)("inlineCode",{parentName:"p"},"update")," rules ",Object(a.b)("em",{parentName:"p"},"before")," the mutation.  Our auth support is still in beta and we may extend this for example to make the ",Object(a.b)("inlineCode",{parentName:"p"},"update")," rule an invariant of the mutation, or enforce pre and post conditions, or even allow custom logic to validate the update data."),Object(a.b)("h2",null,"Update and Add"),Object(a.b)("p",null,"Update mutations can also insert new data.  For example, you might allow a mutation that runs an update mutation to add a new todo."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'mutation {\n    updateUser(input: {\n        filter: { username: { eq: "aUser" }},\n        set: { todos: [ { text: "do this new todo"} ] }\n    }) {\n        ...\n    }\n}\n')),Object(a.b)("p",null,"Such a mutation updates a user's todo list by inserting a new todo.  It would have to satisfy the rules to update the author ",Object(a.b)("em",{parentName:"p"},"and")," the rules to add a todo.  If either fail, the mutation has no effect."),Object(a.b)("hr",null))}u.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-doc-authorization-mutations-mdx-78efdb3e69133b088d97.js.map