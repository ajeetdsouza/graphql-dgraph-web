(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{K6co:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return o})),n.d(t,"default",(function(){return i}));n("rzGZ"),n("Dq+y"),n("8npG"),n("Ggvi"),n("E5k/"),n("q1tI");var a=n("7ljp"),r=n("Bl7J");var o={},l={_frontmatter:o},s=r.a;function i(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["components"]);return Object(a.b)(s,Object.assign({},l,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",null,n.pageContext.frontmatter.title),Object(a.b)("p",null,"Given an authentication mechanism and signed JWT, it's the ",Object(a.b)("inlineCode",{parentName:"p"},"@auth")," directive that tells Dgraph how to apply authorization.  The directive can be used on any type (that isn't a ",Object(a.b)("inlineCode",{parentName:"p"},"@remote")," type) and specifies the authorization for ",Object(a.b)("inlineCode",{parentName:"p"},"query")," as well as ",Object(a.b)("inlineCode",{parentName:"p"},"add"),", ",Object(a.b)("inlineCode",{parentName:"p"},"update")," and ",Object(a.b)("inlineCode",{parentName:"p"},"delete")," mutations."),Object(a.b)("p",null,"In each case, ",Object(a.b)("inlineCode",{parentName:"p"},"@auth")," specifies rules that Dgraph applies during queries and mutations.  Those rules are expressed in exactly the same syntax as GraphQL queries.  Why?  Because the authorization you add to your app is about the graph of your application, so graph rules make sense.  It's also the syntax you already know about, you get syntax help from GraphQL tools in writing such rules, and it turns out to be exactly the kinds of rules Dgraph already knows how to evaluate."),Object(a.b)("p",null,"Here's how the rules work."),Object(a.b)("h2",null,"Authorization rules"),Object(a.b)("p",null,"A valid type and rule looks like the following."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type Todo @auth(\n    query: { rule: """\n        query ($USER: String!) { \n            queryTodo(filter: { owner: { eq: $USER } } ) { \n                id \n            } \n        }"""\n    }\n){\n    id: ID!\n    text: String! @search(by: [term])\n    owner: String!\n}\n')),Object(a.b)("p",null,"Here we define a type ",Object(a.b)("inlineCode",{parentName:"p"},"Todo"),", that's got an ",Object(a.b)("inlineCode",{parentName:"p"},"id"),", the ",Object(a.b)("inlineCode",{parentName:"p"},"text")," of the todo and the username of the ",Object(a.b)("inlineCode",{parentName:"p"},"owner")," of the todo.  What todos can a user query?  Any ",Object(a.b)("inlineCode",{parentName:"p"},"Todo")," that the ",Object(a.b)("inlineCode",{parentName:"p"},"query")," rule would also return."),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"query")," rule in this case expects the JWT to contain a claim ",Object(a.b)("inlineCode",{parentName:"p"},'"USER": "..."')," giving the username of the logged in user, and says: you can query any todo that has your username as the owner."),Object(a.b)("p",null,"This rule is applied automatically at query time.  For example, the query"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),"query {\n    queryTodo {\n        id\n        text\n    }\n}\n")),Object(a.b)("p",null,"will return only the todo's where ",Object(a.b)("inlineCode",{parentName:"p"},"owner")," equals ",Object(a.b)("inlineCode",{parentName:"p"},"amit"),", when Amit is logged in and only the todos owned by ",Object(a.b)("inlineCode",{parentName:"p"},"nancy")," when she's logged into your app."),Object(a.b)("p",null,"Similarly,"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'query {\n    queryTodo(filter: { text: { anyofterms: "graphql"}}, first: 10, order: { asc: text }) {\n        id\n        text\n    }\n}\n')),Object(a.b)("p",null,"will return the first ten todos, ordered ascending by title of the user that made the query."),Object(a.b)("p",null,"This means your frontend doesn't need to be sensitive to the auth rules.  Your app can simply query for the todos and that query behaves properly depending on who's logged in."),Object(a.b)("p",null,"In general, an auth rule should select a field that's expected to exist at the inner most field, often that's the ",Object(a.b)("inlineCode",{parentName:"p"},"ID")," or ",Object(a.b)("inlineCode",{parentName:"p"},"@id")," field.  Auth rules are run in a mode that requires all fields in the rule to find a value in order to succeed.  "),Object(a.b)("h2",null,"Graph traversal in auth rules"),Object(a.b)("p",null,"Often authorization depends not on the object being queried, but on the connections in the graph that object has or doesn't have.  Because the auth rules are graph queries, they can express very powerful graph search and traversal."),Object(a.b)("p",null,"For a simple todo app, it's more likely that you'll have types like this:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),"type User {\n    username: String! @id\n    todos: [Todo]\n}\n\ntype Todo {\n    id: ID!\n    text: String!\n    owner: User\n}\n")),Object(a.b)("p",null,"This means your auth rule for todos will depend not on a value in the todo, but on checking which owner it's linked to.  This means our auth rule must make a step further into the graph to check who the owner is."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),"query ($USER: String!) { \n    queryTodo {\n        owner(filter: { username: { eq: $USER } } ) { \n            username\n        } \n    } \n}\n")),Object(a.b)("p",null,"You can express a lot with these kinds of graph traversals.  For example, multitenancy rules can express that you can only see an object if it's linked (through what ever graph search you define) to the organization you were authenticated from.  That means your app can split data per customer easily."),Object(a.b)("p",null,"You can also express rules that can be administered by the app itself.  You might define type ",Object(a.b)("inlineCode",{parentName:"p"},"Role")," and enum ",Object(a.b)("inlineCode",{parentName:"p"},"Privileges")," that can have values like ",Object(a.b)("inlineCode",{parentName:"p"},"VIEW"),", ",Object(a.b)("inlineCode",{parentName:"p"},"ADD"),", etc. and state in your auth rules that a user needs to have a role with particular privileges to query/add/update/delete and those roles can then be allocated inside the app.  For example, in an app about project management, when a project is created the admin can decide which users have view or edit permission, etc."),Object(a.b)("h2",null,"Role Based Access Control"),Object(a.b)("p",null,"As well as rules that relate a user's claims to a graph traversal, role based access control rules are also possible.  These rules relate a claim in the JWT to a known value.  "),Object(a.b)("p",null,"For example, perhaps only someone logged in with the ",Object(a.b)("inlineCode",{parentName:"p"},"ADMIN")," role is allowed to delete users.  For that, we might expect the JWT to contain a claim ",Object(a.b)("inlineCode",{parentName:"p"},'"ROLE": "ADMIN"'),", and can thus express a rule that only allows users with the ",Object(a.b)("inlineCode",{parentName:"p"},"ADMIN")," claim to delete."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type User @auth(\n    delete: { rule:  "{$ROLE: { eq: \\"ADMIN\\" } }"}\n) { \n    username: String! @id\n    todos: [Todo]\n}\n')),Object(a.b)("p",null,"Not all claims need to be present in all JWTs.  For example, if the ",Object(a.b)("inlineCode",{parentName:"p"},"ROLE")," claim isn't present in a JWT, any rule that relies on ",Object(a.b)("inlineCode",{parentName:"p"},"ROLE")," simply evaluates to false.  As well as simplifying your JWTs (e.g. not all users need a role if it doesn't make sense to do so), this means you can also simply disallow some queries and mutations.  If you know that your JWTs never contain the claim ",Object(a.b)("inlineCode",{parentName:"p"},"DENIED"),", then a rule such as"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type User @auth(\n    delete: { rule:  "{$DENIED: { eq: \\"DENIED\\" } }"}\n) { \n    ...\n}\n')),Object(a.b)("p",null,"can never be true and this would prevent users ever being deleted."),Object(a.b)("h2",null,"and, or & not"),Object(a.b)("p",null,"Rules can be combined with the logical connectives and, or and not, so a permission can be a mixture of graph traversals and role based rules."),Object(a.b)("p",null,"In the todo app, you can express, for example, that you can delete a ",Object(a.b)("inlineCode",{parentName:"p"},"Todo")," if you are the author, or are the site admin."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type Todo @auth(\n    delete: { or: [ \n        { rule:  "query ($USER: String!) { ... }" }, # you are the author graph query\n        { rule:  "{$ROLE: { eq: \\"ADMIN\\" } }" }\n    ]}\n)\n')),Object(a.b)("h2",null,"Public Data"),Object(a.b)("p",null,"Many apps have data that can be accessed by anyone, logged in or not.  That also works nicely with Dgraph auth rules.  "),Object(a.b)("p",null,"For example, in Twitter, StackOverflow, etc. you can see authors and posts without being signed it - but you'd need to be signed in to add a post.  With Dgraph auth rules, if a type doesn't have, for example, a ",Object(a.b)("inlineCode",{parentName:"p"},"query")," auth rule or the auth rule doesn't depend on a JWT value, then the data can be accessed without a signed JWT."),Object(a.b)("p",null,"For example, the todo app might allow anyone, logged in or not, to view any author, but not make any mutations unless logged in as the author or an admin.  That would be achieved by rules like the following."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type User @auth(\n    # no query rule\n    add: { rule:  "{$ROLE: { eq: \\"ADMIN\\" } }" },\n    update: ...\n    delete: ...\n) {\n    username: String! @id\n    todos: [Todo]\n}\n')),Object(a.b)("p",null,"Maybe some todos can be marked as public and users you aren't logged in can see those."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type Todo @auth(\n    query: { or: [\n        # you are the author \n        { rule: ... },\n        # or, the todo is marked as public\n        { rule: """query { \n            queryTodo(filter: { isPublic: { eq: true } } ) { \n                id \n            } \n        }"""}\n    ]}\n) { \n    ...\n    isPublic: Boolean\n}\n\n')),Object(a.b)("p",null,"Because the rule doesn't depend on a JWT value, it can be successfully evaluated for users who aren't logged in."),Object(a.b)("p",null,"Ensuring that requests are from an authenticated JWT, and no further restrictions, can be done by arranging the JWT to contain a value like ",Object(a.b)("inlineCode",{parentName:"p"},'"isAuthenticated": "true"'),".  For example,"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type User @auth(\n    query: { rule:  "{$isAuthenticated: { eq: \\"true\\" } }" },\n) {\n    username: String! @id\n    todos: [Todo]\n}\n')),Object(a.b)("p",null,"specifies that only authenticated users can query other users."),Object(a.b)("hr",null))}i.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-doc-authorization-directive-mdx-1155b0b40d6e7a9dff8a.js.map