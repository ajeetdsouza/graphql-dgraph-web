(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{taj2:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return i})),n.d(t,"default",(function(){return s}));n("rzGZ"),n("Dq+y"),n("8npG"),n("Ggvi"),n("E5k/"),n("q1tI");var a=n("7ljp"),o=n("Bl7J");var i={},r={_frontmatter:i},l=o.a;function s(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,["components"]);return Object(a.b)(l,Object.assign({},r,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",null,n.pageContext.frontmatter.title),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"@custom")," directive is used to define custom queries, mutations and fields."),Object(a.b)("p",null,"In all cases, the result type (of the query, mutation or field) can be either:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"a type that's stored in Dgraph (that's any type you've defined in your schema), or"),Object(a.b)("li",{parentName:"ul"},"a type that's not stored in Dgraph and is marked with the ",Object(a.b)("inlineCode",{parentName:"li"},"@remote")," directive.")),Object(a.b)("p",null,"Because the result types can be local or remote, you can call other HTTP endpoints, call remote GraphQL, or even call back to your Dgraph instance to add extra logic on top of Dgraph's graph search or mutations."),Object(a.b)("p",null,"Here's the GraphQL definition of the directives:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),"directive @custom(http: CustomHTTP) on FIELD_DEFINITION\ndirective @remote on OBJECT | INTERFACE\n\ninput CustomHTTP {\n    url:            String!\n    method:         HTTPMethod!\n    forwardHeaders: [String!]\n    mode:           Mode\n    body:           String\n    graphql:        String\n    skipIntrospection: Boolean\n}\n\nenum HTTPMethod { GET POST PUT PATCH DELETE }\nenum Mode { SINGLE BATCH }\n")),Object(a.b)("p",null,"Each definition of custom logic must include:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"the ",Object(a.b)("inlineCode",{parentName:"li"},"url")," where the custom logic is called.  This can include a path and parameters that depend on query/mutation arguments or other fields."),Object(a.b)("li",{parentName:"ul"},"the HTTP ",Object(a.b)("inlineCode",{parentName:"li"},"method")," to use in the call.  For example, when calling a REST endpoint with ",Object(a.b)("inlineCode",{parentName:"li"},"GET"),", ",Object(a.b)("inlineCode",{parentName:"li"},"POST"),", etc.")),Object(a.b)("p",null,"Optionally, the custom logic definition can also include:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"a list of ",Object(a.b)("inlineCode",{parentName:"li"},"forwardHeaders")," to take from the incoming request and add to the outgoing HTTP call.  Used, for example, if the incoming request contains an auth token that must be passed to the custom logic."),Object(a.b)("li",{parentName:"ul"},"a ",Object(a.b)("inlineCode",{parentName:"li"},"body")," definition that can be used to construct a HTTP body from from arguments or fields."),Object(a.b)("li",{parentName:"ul"},"the ",Object(a.b)("inlineCode",{parentName:"li"},"graphql")," query/mutation to call if the custom logic is a GraphQL server and whether to introspect or not (",Object(a.b)("inlineCode",{parentName:"li"},"skipIntrospection"),") the remote GraphQL endpoint.")),Object(a.b)("p",null,"The result type of custom queries and mutations can be any object type in your schema, including ",Object(a.b)("inlineCode",{parentName:"p"},"@remote")," types.  For custom fields the type can be object types or scalar types."),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"method")," can be any of the HTTP methods: ",Object(a.b)("inlineCode",{parentName:"p"},"GET"),", ",Object(a.b)("inlineCode",{parentName:"p"},"POST"),", ",Object(a.b)("inlineCode",{parentName:"p"},"PUT"),", ",Object(a.b)("inlineCode",{parentName:"p"},"PATCH"),", or ",Object(a.b)("inlineCode",{parentName:"p"},"DELETE"),", and ",Object(a.b)("inlineCode",{parentName:"p"},"forwardHeaders")," is a list of headers that should be passed from the incoming request to the outgoing HTTP custom request.  Let's look at each of the other ",Object(a.b)("inlineCode",{parentName:"p"},"http")," arguments in detail."),Object(a.b)("h2",null,"The URL and method"),Object(a.b)("p",null,"The URL can be as simple as a fixed URL string, or include details drawn from the arguments or fields."),Object(a.b)("p",null,"A simple string might look like:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type Query {\n    myCustomQuery: MyResult @custom(http: {\n        url: "https://my.api.com/theQuery",\n        method: GET\n    })\n}\n')),Object(a.b)("p",null,"While, in more complex cases, the arguments of the query/mutation can be used as a pattern for the URL:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type Query {\n    myGetPerson(id: ID!): Person @custom(http: {\n        url: "https://my.api.com/person/$id",\n        method: GET\n    })\n\n    getPosts(authorID: ID!, numToFetch: Int!): [Post] @custom(http: {\n        url: "https://my.api.com/person/$authorID/posts?limit=$numToFetch",\n        method: GET\n    })\n}\n')),Object(a.b)("p",null,"In this case, a query like"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'query {\n    getPosts(authorID: "auth123", numToFetch: 10) { \n        title \n    }\n}\n')),Object(a.b)("p",null,"gets transformed to an outgoing HTTP GET request to the URL ",Object(a.b)("inlineCode",{parentName:"p"},"https://my.api.com/person/auth123/posts?limit=10"),"."),Object(a.b)("p",null,"When using custom logic on fields, the URL can draw from other fields in the type.  For example:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type User {\n    username: String! @id\n    ...\n    posts: [Post] @custom(http: {\n        url: "https://my.api.com/person/$username/posts",\n        method: GET\n    })\n}\n')),Object(a.b)("p",null,"Note that:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Fields or arguments used in the path of a URL, such as ",Object(a.b)("inlineCode",{parentName:"li"},"username")," or ",Object(a.b)("inlineCode",{parentName:"li"},"authorID")," in the exapmles above, must be marked as non-nullable (have ",Object(a.b)("inlineCode",{parentName:"li"},"!")," in their type); whereas, those used in parameters, such as ",Object(a.b)("inlineCode",{parentName:"li"},"numToFetch"),", can be nullable."),Object(a.b)("li",{parentName:"ul"},"Currently, only scalar fields or arguments are allowed to be used in URLs or bodies; though, see body below, this doesn't restrict the objects you can construct and pass to custom logic functions.")),Object(a.b)("h2",null,"The body"),Object(a.b)("p",null,"Many HTTP requests, such as add and update operations on REST APIs, require a JSON formatted body to supply the data.  In a similar way to how ",Object(a.b)("inlineCode",{parentName:"p"},"url")," allows specifying a url pattern to use in resolving the custom request, Dgraph allows a ",Object(a.b)("inlineCode",{parentName:"p"},"body")," pattern that is used to build HTTP request bodies."),Object(a.b)("p",null,"For example, this body can be structured JSON that relates a mutation's arguments to the JSON structure required by the remote endpoint."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type Mutation {\n    newMovie(title: String!, desc: String, dir: ID, imdb: ID): Movie @custom(http: {\n            url: "http://myapi.com/movies",\n            method: "POST",\n            body: "{ title: $title, imdbID: $imdb, storyLine: $desc, director: { id: $dir }}",\n    })\n')),Object(a.b)("p",null,"A request with ",Object(a.b)("inlineCode",{parentName:"p"},'newMovie(title: "...", desc: "...", dir: "dir123", imdb: "tt0120316")')," is transformed into a ",Object(a.b)("inlineCode",{parentName:"p"},"POST")," request to ",Object(a.b)("inlineCode",{parentName:"p"},"http://myapi.com/movies")," with a JSON body of:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-json"}),'{\n    "title": "...",\n    "imdbID": "tt0120316",\n    "storyLine": "...",\n    "director": {\n        "id": "dir123"\n    }\n}\n')),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"url")," and ",Object(a.b)("inlineCode",{parentName:"p"},"body")," templates can be used together in a single custom definition."),Object(a.b)("p",null,"For both ",Object(a.b)("inlineCode",{parentName:"p"},"url")," and ",Object(a.b)("inlineCode",{parentName:"p"},"body")," templates, any non-null arguments or fields must be present to evaluate the custom logic.  And the following rules are applied when building the request from the template for nullable arguments or fields."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"If the value of a nullable argument is present, it's used in the template."),Object(a.b)("li",{parentName:"ul"},"If a nullable argument is present, but null, then in a body ",Object(a.b)("inlineCode",{parentName:"li"},"null")," is inserted, while in a url nothing is added.  For example, if the ",Object(a.b)("inlineCode",{parentName:"li"},"desc")," argument above is null then ",Object(a.b)("inlineCode",{parentName:"li"},"{ ..., storyLine: null, ...}")," is constructed for the body.  Whereas, in a URL pattern like ",Object(a.b)("inlineCode",{parentName:"li"},"https://a.b.c/endpoint?arg=$gqlArg"),", if ",Object(a.b)("inlineCode",{parentName:"li"},"gqlArg")," is present, but null, the generated URL is ",Object(a.b)("inlineCode",{parentName:"li"},"https://a.b.c/endpoint?arg="),"."),Object(a.b)("li",{parentName:"ul"},"If a nullable argument is not present, nothing is added to the URL/body.  That would mean the constructed body would not contain ",Object(a.b)("inlineCode",{parentName:"li"},"storyLine")," if the ",Object(a.b)("inlineCode",{parentName:"li"},"desc")," argument is missing, and in ",Object(a.b)("inlineCode",{parentName:"li"},"https://a.b.c/endpoint?arg=$gqlArg")," the result would be ",Object(a.b)("inlineCode",{parentName:"li"},"https://a.b.c/endpoint")," if ",Object(a.b)("inlineCode",{parentName:"li"},"gqlArg")," were not present in the request arguments.")),Object(a.b)("h2",null,"Calling GraphQL custom resolvers"),Object(a.b)("p",null,"Custom queries, mutations and fields can be implemented by custom GraphQL resolvers.  In this case, use the ",Object(a.b)("inlineCode",{parentName:"p"},"graphql")," argument to specify which query/mutation on the remote server to call.  The syntax includes if the call is a query or mutation, the arguments, and what query/mutation to use on the remote endpoint."),Object(a.b)("p",null,"For example, you can pass arguments to queries onward as arguments to remote GraphQL endpoints:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type Query {\n    getPosts(authorID: ID!, numToFetch: Int!): [Post] @custom(http: {\n        url: "https://my.api.com/graphql",\n        method: POST,\n        graphql: "query($authorID: ID!, $numToFetch: Int!) { posts(auth: $authorID, first: $numToFetch) }"\n    })\n}\n')),Object(a.b)("p",null,"You can also define your own inputs and pass those to the remote GraphQL endpoint."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'input NewMovieInput { ... }\n\ntype Mutation {\n    newMovie(input: NewMovieInput!): Movie @custom(http: {\n        url: "http://movies.com/graphql",\n        method: "POST",\n        graphql: "mutation($input: NewMovieInput!) { addMovie(data: $input) }",\n    })\n')),Object(a.b)("p",null,"When a schema is uploaded, Dgraph will try to introspect the remote GraphQL endpoints on any custom logic that uses the ",Object(a.b)("inlineCode",{parentName:"p"},"graphql")," argument.  From the results of introspection, it tries to match up arguments, input and object types to ensure that the calls to and expected responses from the remote GraphQL make sense."),Object(a.b)("p",null,"If that introspection isn't possible, set ",Object(a.b)("inlineCode",{parentName:"p"},"skipIntrospection: true")," in the custom definition and Dgraph won't perform GraphQL schema introspection for this custom definition.  "),Object(a.b)("h2",null,"Remote types"),Object(a.b)("p",null,"Any type annotated with the ",Object(a.b)("inlineCode",{parentName:"p"},"@remote")," directive is not stored in Dgraph.  This allows your Dgraph GraphQL instance to serve an API that includes both data stored locally and data stored or generated elsewhere.  You can also use custom fields, for example, to join data from disparate datasets."),Object(a.b)("p",null,"Remote types can only be returned by custom resolvers and Dgraph won't generate any search or CRUD operations for remote types."),Object(a.b)("p",null,"The schema definition used to define your Dgraph GraphQL API must include definitions of all the types used.  If a custom logic call returns a type not stored in Dgraph, then that type must be added to the Dgraph schema with the ",Object(a.b)("inlineCode",{parentName:"p"},"@remote")," directive."),Object(a.b)("p",null,"For example, you api might use custom logic to integrate with GitHub, using either ",Object(a.b)("inlineCode",{parentName:"p"},"https://api.github.com")," or the GitHub GraphQL api ",Object(a.b)("inlineCode",{parentName:"p"},"https://api.github.com/graphql")," and calling the ",Object(a.b)("inlineCode",{parentName:"p"},"user")," query.  Either way, your GraphQL schema will need to include the type you expect back from that remote call.  That could be linking a ",Object(a.b)("inlineCode",{parentName:"p"},"User")," as stored in your Dgraph instance  with the ",Object(a.b)("inlineCode",{parentName:"p"},"Repository")," data from GitHub.  With ",Object(a.b)("inlineCode",{parentName:"p"},"@remote")," types, that's as simple as adding the type and custom call to your  schema."),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'# GitHub\'s repository type\ntype Respository @remote { ... }\n\n# Dgraph user type\ntype User {\n    # local user name = GitHub id\n    username: String! @id \n\n    # ... \n    # other data stored in Dgraph\n    # ...\n\n    # join local data with remote\n    repositories: [Repository] @custom(http: {\n        url:  "https://api.github.com/users/$username/repos",\n        method: GET\n    })\n}\n')),Object(a.b)("p",null,"Just defining the connection is all it takes and then you can ask a single GraphQL query that performs a local query and joins with (potentialy many) remote data sources."),Object(a.b)("h2",null,"How Dgraph processes custom results"),Object(a.b)("p",null,"Given types like"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),"type Post @remote {\n    id: ID!\n    title: String!\n    datePublished: DateTime\n    author: Author\n}\n\ntype Author { ... }\n")),Object(a.b)("p",null,"and a custom query"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type Query {\n    getPost(id: ID!): Post @custom(http: {\n        url: "https://my.api.com/post/$id",\n        method: GET\n    })\n\n    getPosts(authorID: ID!, numToFetch: Int!): [Post] @custom(http: {\n        url: "https://my.api.com/person/$authorID/posts?limit=$numToFetch",\n        method: GET\n    })\n}\n')),Object(a.b)("p",null,"Dgraph turns the ",Object(a.b)("inlineCode",{parentName:"p"},"getPost")," query into a HTTP request to ",Object(a.b)("inlineCode",{parentName:"p"},"https://my.api.com/post/$id")," and expects a single JSON object with fields ",Object(a.b)("inlineCode",{parentName:"p"},"id"),", ",Object(a.b)("inlineCode",{parentName:"p"},"title"),", ",Object(a.b)("inlineCode",{parentName:"p"},"datePublished")," and ",Object(a.b)("inlineCode",{parentName:"p"},"author")," as result.  Any additional fields are ignored, while if non-nullable fields (like ",Object(a.b)("inlineCode",{parentName:"p"},"id")," and ",Object(a.b)("inlineCode",{parentName:"p"},"title"),") are missing, GraphQL error propagation will be triggered."),Object(a.b)("p",null,"For ",Object(a.b)("inlineCode",{parentName:"p"},"getPosts"),", Dgraph expects the HTTP call to ",Object(a.b)("inlineCode",{parentName:"p"},"https://my.api.com/person/$authorID/posts?limit=$numToFetch")," to return a JSON array of JSON objects, with each object matching the ",Object(a.b)("inlineCode",{parentName:"p"},"Post")," type as described above."),Object(a.b)("p",null,"If the custom resolvers are GraphQL calls, like:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type Query {\n    getPost(id: ID!): Post @custom(http: {\n        url: "https://my.api.com/graphql",\n        method: POST,\n        graphql: "query(id: ID) { post(postID: $id) }"\n    })\n\n    getPosts(authorID: ID!, numToFetch: Int!): [Post] @custom(http: {\n        url: "https://my.api.com/graphql",\n        method: POST,\n        graphql: "query(id: ID) { postByAuthor(authorID: $id, first: $numToFetch) }"\n    })\n}\n')),Object(a.b)("p",null,"then Dgraph expects a GraphQL call to ",Object(a.b)("inlineCode",{parentName:"p"},"post")," to return a valid GraphQL result like ",Object(a.b)("inlineCode",{parentName:"p"},'{ "data": { "post": {...} } }')," and will use the JSON object that is the value of ",Object(a.b)("inlineCode",{parentName:"p"},"post")," as the data resolved by the request."),Object(a.b)("p",null,"Similarly, Dgraph expects ",Object(a.b)("inlineCode",{parentName:"p"},"postByAuthor")," to return data like ",Object(a.b)("inlineCode",{parentName:"p"},'{ "data": { "postByAuthor": [ {...}, ... ] } }')," and will use the array value of ",Object(a.b)("inlineCode",{parentName:"p"},"postByAuthor")," to build its array of posts result."),Object(a.b)("h2",null,"How custom fields are resolved"),Object(a.b)("p",null,"When evaluating a request that includes custom fields, Dgraph might run multiple resolution stages to resolve all the fields.  Dgraph must also ensure it requests enough data to forfull the custom fields.  For example, given the ",Object(a.b)("inlineCode",{parentName:"p"},"User")," type defined as:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),'type User {\n    username: String! @id\n    ...\n    posts: [Post] @custom(http: {\n        url: "https://my.api.com/person/$username/posts",\n        method: GET\n    })\n}\n')),Object(a.b)("p",null,"a query such as:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),"query {\n    queryUser {\n        username\n        posts\n    }\n}\n")),Object(a.b)("p",null,"is executed by first querying in Dgraph for ",Object(a.b)("inlineCode",{parentName:"p"},"username")," and then using the result to resolve the custom field ",Object(a.b)("inlineCode",{parentName:"p"},"posts")," (which relies on ",Object(a.b)("inlineCode",{parentName:"p"},"username"),").  For a request like:"),Object(a.b)("pre",null,Object(a.b)("code",Object.assign({parentName:"pre"},{className:"language-graphql"}),"query {\n    queryUser {\n        posts\n    }\n}\n")),Object(a.b)("p",null,"Dgraph works out that it must first get ",Object(a.b)("inlineCode",{parentName:"p"},"username")," so it can run the custom field ",Object(a.b)("inlineCode",{parentName:"p"},"posts"),", even though ",Object(a.b)("inlineCode",{parentName:"p"},"username")," isn't part of the original query.  So Dgraph retrieves enough data to satisfy the custom request, even if that involves data that isn't asked for in the query."),Object(a.b)("p",null,"There are currently a few limitations on custom fields: "),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"each custom call must include either an ",Object(a.b)("inlineCode",{parentName:"li"},"ID")," or ",Object(a.b)("inlineCode",{parentName:"li"},"@id")," field"),Object(a.b)("li",{parentName:"ul"},"arguments are not allowed (soon custom field arguments will be allowed and will be used in the ",Object(a.b)("inlineCode",{parentName:"li"},"@custom")," directive in the same manner as for custom queries and mutations), and"),Object(a.b)("li",{parentName:"ul"},"a custom field can't depend on another custom field (longer term, we intend to lift this restriction).")),Object(a.b)("h2",null,"Restrictions / Roadmap"),Object(a.b)("p",null,"Our custom logic is still in beta and we are improving it quickly.  Here's a few points that we plan to work on soon:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"adding arguments to custom fields"),Object(a.b)("li",{parentName:"ul"},"relaxing the restrictions on custom fields using id values"),Object(a.b)("li",{parentName:"ul"},"iterative evaluation of ",Object(a.b)("inlineCode",{parentName:"li"},"@custom")," and ",Object(a.b)("inlineCode",{parentName:"li"},"@remote")," - in the current version you can't have ",Object(a.b)("inlineCode",{parentName:"li"},"@custom")," inside an ",Object(a.b)("inlineCode",{parentName:"li"},"@remote")," type once we add this, you'll be able to extend remote types with custom fields, and"),Object(a.b)("li",{parentName:"ul"},"allowing fine tuning of the generated API, for example removing of customizing the generated CRUD mutations.")),Object(a.b)("hr",null))}s.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-doc-custom-directive-mdx-2bb1721ebdeac6d7c5ee.js.map